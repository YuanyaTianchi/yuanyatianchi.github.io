

+++

title = "OS"
description = "OS"
tags = ["it","base"]

+++



# OS



## 调度

- 操作系统的三大调度机制
  - **进程调度**：先来先服务调度算法、最短作业优先调度算法、高响应比优先调度算法、时间片轮转调度算法、最高优先级调度算法、多级反馈队列调度算法
  - **页面置换**：最佳页面置换算法、先进先出置换算法、最近最久未使用的置换算法、时钟页面置换算法、最不常用置换算法
  - **磁盘调度算法**：先来先服务算法、最短寻道时间优先算法、扫描算法算法、循环扫描算法、LOOK与C-LOOK算法

### 进程调度

- 进程调度（cpu调度）：当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU
- 发生cpu调度的情况有
  - 当进程从运行状态转到等待状态（非抢占式）：
  - 当进程从运行状态转到就绪状态（抢占式）：通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU
  - 当进程从等待状态转到就绪状态（抢占式）：假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态，一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度
  - 当进程从运行状态转到终止状态；（非抢占式）
- 非抢占式：当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程
- 抢占式调度：进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则
- 调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程真在使用 CPU 的时间和 I/O 时间
- 算法
  - 先来先服务：每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行
  - 最短作业优先（Shortest Job First, SJF）：优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。对长作业不利，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行
  - 高响应比优先（Highest Response Ratio Next, HRRN）：权衡了短作业和长作业，**每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行**，优先权=(等待时间＋要求服务时间)/要求服务时间，可以发现
    - 如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；
    - 如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会
  - 时间片轮转：最古老、最简单、最公平且使用最广的算法，**每个进程被分配一个时间段，称为时间片（\*Quantum\*），即允许该进程在该时间段中运行**。「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样
    - 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；
    - 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换
    - 时间片的长度：
      - 如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；
      - 如果设得太长又可能引起对短作业进程的响应时间变长
      - 通常时间片设为 `20ms~50ms` 通常是一个比较合理的折中值
  - 最高优先级调度：多用户计算机系统希望调度是有优先级的，即希望调度程序能**从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（\*Highest Priority First，HPF\*）调度算法**
    - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化
    - 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是**随着时间的推移增加等待进程的优先级**
    - 该算法也有两种处理优先级高的方法
      - 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程
      - 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行
    - 缺点：可能会导致低优先级的进程永远不会运行
  - 多级反馈队列（Multilevel Feedback Queue）：时间片轮转算法」和「最高优先级算法」的综合和发展
    - 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短，
    - 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列
    - 设置了多个队列，赋予每个队列不同的优先级，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；
    - 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
    - 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行
    - 对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的**兼顾了长短作业，同时有较好的响应时间**
  - 内存页面置换
    - **缺页异常（缺页中断）**：当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：
      - 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。
      - 缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行

